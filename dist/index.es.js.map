{"version":3,"file":"index.es.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/utils/weak-maps.ts","../src/create-editor.ts","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../src/utils/string.ts","../src/interfaces/editor.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: (direction?: 'forward' | 'backward') => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, { reverse: direction === 'backward' })\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const child = node.children[i] as Descendant\n        const prev = node.children[i - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { createDraft, finishDraft, isDraft } from 'immer'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  Descendant,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface Editor {\n  children: Node[]\n  selection: Range | null\n  operations: Operation[]\n  marks: Record<string, any> | null\n  [key: string]: unknown\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: (direction?: 'forward' | 'backward') => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport const Editor = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(editor: Editor, direction?: 'forward' | 'backward'): void {\n    editor.deleteFragment(direction)\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    return (\n      isPlainObject(value) &&\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    )\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Record<string, any> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.last(editor, at)\n    const [, to] = Editor.last(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ) {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = getDirtyPaths(editor).pop()!\n        const entry = Editor.node(editor, path)\n        editor.normalizeNode(entry)\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        if (editor.isInline(node)) {\n          continue\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          const text = Editor.string(editor, { anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.first(editor, at)\n    const [, to] = Editor.first(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  string(editor: Editor, at: Location): string {\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    fn()\n    NORMALIZING.set(editor, value)\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\ntype NodeMatch<T extends Node> =\n  | ((node: Node) => node is T)\n  | ((node: Node) => boolean)\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface Element {\n  children: Node[]\n  [key: string]: unknown\n}\n\nexport const Element = {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport const Location = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport const Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Element, ElementEntry, Path, Range, Text } from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type Node = Editor | Element | Text\n\nexport const Node = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.selection\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n","import { Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: unknown\n}\n\nexport type RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Range\n      newProperties: null\n    }\n\nexport type SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport const Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport const Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport const PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface Point {\n  path: Path\n  offset: number\n  [key: string]: unknown\n}\n\nexport const Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport const PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: unknown\n}\n\nexport const Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport const RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Range } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface Text {\n  text: string\n  [key: string]: unknown\n}\n\nexport const Text = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    for (const key in text) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    for (const key in another) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= offset + length) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range starts after the leaf, or ends before it, continue.\n        if (\n          start.offset > offset + length ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < offset + length) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport const GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\n\nexport const NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n =>\n          levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const { text, children, ...properties } = node\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path) as NodeEntry<Ancestor>\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry as NodeEntry<Ancestor>\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport const SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor) {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location) {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>) {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport const TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = reverse\n        ? startRef.unref() || endRef.unref()\n        : endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n"],"names":["DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","apply","op","ref","Editor","pathRefs","PathRef","transform","pointRefs","PointRef","rangeRefs","RangeRef","set","Set","dirtyPaths","add","path","key","join","has","push","oldDirtyPaths","get","newDirtyPaths","getDirtyPaths","newPath","Path","Transforms","normalize","type","Promise","resolve","then","addMark","value","Range","isExpanded","setNodes","match","Text","isText","split","deleteBackward","unit","isCollapsed","delete","reverse","deleteForward","deleteFragment","direction","getFragment","Node","fragment","insertBreak","splitNodes","always","insertFragment","insertNode","node","insertNodes","insertText","text","inline","above","n","mode","inlinePath","isEnd","anchor","point","after","setSelection","focus","normalizeNode","entry","Element","isElement","length","child","at","concat","voids","shouldHaveInlines","isEditor","i","prev","isLast","isInlineOrText","removeNodes","newChild","equals","loose","mergeNodes","removeMark","unsetNodes","levels","descendants","Array","from","nodes","p","ancestors","previousPath","previous","oldAncestors","newAncestors","ancestor","newParent","newIndex","resultPath","nextPath","next","objectWithoutPropertiesLoose","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","offset","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","started","char","charAt","l","slice","rest","isWordCharacter","remaining","test","code","options","edge","end","range","distance","d","target","positions","before","start","edges","first","hasBlocks","element","some","isBlock","hasInlines","hasTexts","every","isPlainObject","isRange","isNodeList","Operation","isOperationList","Point","isEdge","isStart","isEmpty","isNormalizing","undefined","last","leaf","block","prevNode","prevPath","blockPath","isAncestor","to","span","isPath","Error","parent","includes","universal","Span","isSpan","nodeEntries","pass","matches","hit","isLower","compare","emit","force","allPaths","withoutNormalizing","max","m","pop","parentPath","depth","firstPath","lastPath","common","isPoint","pathRef","affinity","current","unref","refs","pointRef","string","available","isNewBlock","advance","e","s","reverseText","isFirst","rangeRef","t","unhangRange","endBlock","skip","isBefore","void","fn","isElementList","isArray","props","Location","isLocation","root","index","JSON","stringify","c","childPath","another","descendant","elements","newRoot","produce","r","splice","isNode","visited","isAfter","nextIndex","map","texts","isNodeOperation","isOperation","endsWith","position","properties","newProperties","isSelectionOperation","isTextOperation","inverse","isSibling","inversePath","inverseNewPath","paths","av","bv","min","Math","endsAfter","as","bs","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","al","bl","list","relative","operation","onp","copy","result","isBackward","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isForward","points","affinityAnchor","affinityFocus","isTextList","hasOwnProperty","decorations","leaves","dec","o","Object","assign","middle","off","GeneralTransforms","createDraft","truePath","newNode","finishDraft","isDraft","NodeTransforms","hanging","select","matchPath","isAtEnd","liftNodes","parentNodeEntry","toPath","moveNodes","splitPath","commonPath","isPreviousSibling","emptyAncestor","emptyRef","toRef","targets","depths","splitMode","k","keys","height","deleteRange","beforeRef","highest","voidMatch","nudge","voidNode","voidPath","afterPath","siblingHeight","afterRef","highestPath","lowestPath","obj","unwrapNodes","wrapNodes","roots","rootPath","a","commonNodeEntry","commonNode","wrapperPath","wrapper","SelectionTransforms","collapse","deselect","move","opts","setPoint","oldProps","newProps","TextTransforms","furthestVoid","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef"],"mappings":"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"}